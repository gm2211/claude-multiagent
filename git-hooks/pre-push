#!/bin/sh
#
# pre-push hook — version-bump guard
#
# Rejects a push if any plugin directory has changes (vs the remote tip)
# without a corresponding version bump in marketplace.json.
#
# Delegates to bd pre-push logic first (if available).
#

# --- bd (beads) pre-push delegation ---
if command -v bd >/dev/null 2>&1; then
    bd hooks run pre-push "$@"
    BD_EXIT=$?
    if [ "$BD_EXIT" -ne 0 ]; then
        exit "$BD_EXIT"
    fi
fi

# --- Submodule dirty-check ---
#
# Warn (non-blocking) if any plugin submodules have a checked-out commit that
# differs from the committed pointer.  This catches the common mistake of
# updating a submodule locally (e.g. `cd sub && git pull`) without staging the
# new pointer in the parent repo via `git add <submodule>`.
#
# `git submodule status` prefixes:
#   +  = checked-out commit differs from index (dirty pointer)
#   -  = submodule not initialised
#   U  = merge conflict
# We only flag "+" for submodules under plugins/.

DIRTY_SUBS=""
if git submodule status -- plugins/ 2>/dev/null | grep -q '^\+'; then
    DIRTY_SUBS=$(git submodule status -- plugins/ 2>/dev/null | grep '^\+' | while read -r line; do
        sub_path=$(echo "$line" | awk '{print $2}')
        sub_commit=$(echo "$line" | sed 's/^+//' | awk '{print $1}')
        printf "      %s (checked out: %.8s)\n" "$sub_path" "$sub_commit"
    done)
fi

if [ -n "$DIRTY_SUBS" ]; then
    echo "" >&2
    echo "=== Push rejected: dirty submodule pointers ===" >&2
    echo "  The following plugin submodules have been modified locally" >&2
    echo "  but the new pointer has NOT been committed:" >&2
    echo "" >&2
    printf "%s\n" "$DIRTY_SUBS" >&2
    echo "" >&2
    echo "  Fix: git add <submodule-path> && git commit --amend" >&2
    echo "  Or ignore if this is intentional." >&2
    echo "" >&2
    # Hard-block: reject the push so users don't ship stale submodule content.
    exit 1
fi

# --- Version-bump check ---
#
# Git pre-push hook receives lines on stdin:
#   <local ref> <local sha> <remote ref> <remote sha>
#
# We check each ref being pushed.

MARKETPLACE_JSON=".claude-plugin/marketplace.json"
ERRORS=""

while read -r LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA; do
    # Skip delete pushes
    if [ "$LOCAL_SHA" = "0000000000000000000000000000000000000000" ]; then
        continue
    fi

    # Determine the range of commits being pushed
    if [ "$REMOTE_SHA" = "0000000000000000000000000000000000000000" ]; then
        # New branch — compare against the merge-base with main/master
        DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
        if [ -z "$DEFAULT_BRANCH" ]; then
            DEFAULT_BRANCH="main"
        fi
        BASE=$(git merge-base "$LOCAL_SHA" "origin/$DEFAULT_BRANCH" 2>/dev/null || echo "")
        if [ -z "$BASE" ]; then
            # Can't determine base, skip check
            continue
        fi
        RANGE="${BASE}..${LOCAL_SHA}"
        VERSION_BASE="$BASE"
    else
        RANGE="${REMOTE_SHA}..${LOCAL_SHA}"
        VERSION_BASE="$REMOTE_SHA"
    fi

    for PLUGIN_DIR in plugins/*/; do
        PLUGIN_NAME=$(basename "$PLUGIN_DIR")

        # Check if any files in this plugin changed (excluding metadata files)
        CHANGED=$(git diff --name-only "$RANGE" -- "$PLUGIN_DIR" 2>/dev/null | grep -v "\.claude-plugin/plugin\.json$" | grep -v "\.claude-plugin/marketplace\.json$" || true)
        [ -z "$CHANGED" ] && continue

        # Extract old and new versions from marketplace.json
        OLD_VERSION=$(git show "${VERSION_BASE}:${MARKETPLACE_JSON}" 2>/dev/null | python3 -c "
import json, sys
data = json.load(sys.stdin)
for p in data.get('plugins', []):
    if p.get('name') == '$PLUGIN_NAME':
        print(p.get('version', ''))
        break
" 2>/dev/null)

        NEW_VERSION=$(git show "${LOCAL_SHA}:${MARKETPLACE_JSON}" 2>/dev/null | python3 -c "
import json, sys
data = json.load(sys.stdin)
for p in data.get('plugins', []):
    if p.get('name') == '$PLUGIN_NAME':
        print(p.get('version', ''))
        break
" 2>/dev/null)

        # Plugin has no entry in marketplace.json — skip
        [ -z "$OLD_VERSION" ] && [ -z "$NEW_VERSION" ] && continue

        # New plugin with no prior version — skip
        [ -z "$OLD_VERSION" ] && continue

        if [ "$OLD_VERSION" = "$NEW_VERSION" ] || [ -z "$NEW_VERSION" ]; then
            ERRORS="${ERRORS}\n  - Plugin '$PLUGIN_NAME': files changed but version not bumped (still $OLD_VERSION)"
            ERRORS="${ERRORS}\n    Changed files:"
            while read -r F; do
                ERRORS="${ERRORS}\n      $F"
            done <<< "$CHANGED"
            continue
        fi
    done
done

if [ -n "$ERRORS" ]; then
    echo "" >&2
    echo "=== Push rejected: plugin version issues ===" >&2
    printf "%b\n" "$ERRORS" >&2
    echo "" >&2
    echo "Fix: bump the version in marketplace.json, commit, and retry." >&2
    echo "" >&2
    exit 1
fi

exit 0
